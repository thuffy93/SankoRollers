---
description:
globs:
alwaysApply: false
---
# TypeScript Safety Practices

- **Strict Null Checking**
  - Enable `strictNullChecks` in tsconfig.json
  - Explicitly handle null and undefined cases
  - Use TypeScript's type system to prevent null reference errors
  
  ```typescript
  // In tsconfig.json
  {
    "compilerOptions": {
      "strictNullChecks": true
    }
  }
  
  // ✅ DO: Handle potential undefined values
  function getScoreTerm(scoreMap: Record<string, string> | undefined, score: number): string {
    if (!scoreMap) {
      return 'Par'; // Safe default
    }
    
    const key = score.toString();
    return scoreMap[key] || 'Unknown';
  }
  
  // ❌ DON'T: Ignore nullable types
  function unsafeGetScoreTerm(scoreMap: Record<string, string> | undefined, score: number): string {
    const key = score.toString();
    return scoreMap[key]; // Will throw if scoreMap is undefined
  }
  ```

- **Type Guards and Narrowing**
  - Use type guards to narrow types safely
  - Implement custom type guards for complex types
  
  ```typescript
  // ✅ DO: Use built-in type guards
  function processValue(value: string | number): string {
    if (typeof value === 'string') {
      return value.toUpperCase(); // TypeScript knows value is string here
    }
    return value.toString(); // TypeScript knows value is number here
  }
  
  // ✅ DO: Create custom type guards for complex types
  interface ScoreData {
    value: number;
    term: string;
  }
  
  function isScoreData(obj: any): obj is ScoreData {
    return obj && 
           typeof obj === 'object' && 
           'value' in obj && 
           'term' in obj &&
           typeof obj.value === 'number' &&
           typeof obj.term === 'string';
  }
  
  function processScore(data: unknown): string {
    if (isScoreData(data)) {
      // TypeScript knows data is ScoreData here
      return `${data.term}: ${data.value}`;
    }
    return 'Invalid score data';
  }
  
  // ❌ DON'T: Use type assertions without validation
  function unsafeProcessScore(data: unknown): string {
    const score = data as ScoreData; // Dangerous assumption
    return `${score.term}: ${score.value}`; // May fail at runtime
  }
  ```

- **Record Type for Dictionary Objects**
  - Use `Record<K, V>` for type-safe dictionaries
  - Add index signatures for custom object types that act as dictionaries
  
  ```typescript
  // ✅ DO: Use Record for dictionaries
  type ScoreTerms = Record<string, string>;
  
  const scoreTermMap: ScoreTerms = {
    '-3': 'Eagle',
    '-2': 'Birdie',
    '-1': 'Bogey',
    '0': 'Par'
  };
  
  // ✅ DO: Use index signatures for custom dictionary types
  interface ScoreOptions {
    [key: string]: {
      term: string;
      color: string;
    }
  }
  
  const scoreOptions: ScoreOptions = {
    '-1': { term: 'Bogey', color: 'red' },
    '0': { term: 'Par', color: 'black' }
  };
  
  // ❌ DON'T: Use object literal without type
  const unsafeScoreMap = {
    '-1': 'Bogey',
    '0': 'Par'
  };
  
  // Type is { '-1': string, '0': string } which doesn't allow access with dynamic keys
  ```

- **Safe Optional Property Access**
  - Use optional chaining (`?.`) and nullish coalescing (`??`) operators
  - Prefer optional chaining over conditional checks for deep property access
  
  ```typescript
  // ✅ DO: Use optional chaining
  const scoreTerm = gameData?.score?.term;
  
  // ✅ DO: Combine with nullish coalescing for defaults
  const displayText = gameData?.score?.term ?? 'Par';
  
  // ❌ DON'T: Use multiple conditional checks
  let scoreTerm;
  if (gameData && gameData.score && gameData.score.term) {
    scoreTerm = gameData.score.term;
  }
  ```

- **Strong Typing for Function Parameters**
  - Use specific types rather than 'any'
  - Add explicit return types to functions
  - Make invalid states unrepresentable with proper typing
  
  ```typescript
  // ✅ DO: Use specific parameter and return types
  function calculateScore(strokes: number, par: number): number {
    return strokes - par;
  }
  
  // ✅ DO: Use union types for limited set of values
  type ScoreType = 'par' | 'bogey' | 'birdie' | 'eagle';
  
  function getScoreType(strokes: number, par: number): ScoreType {
    const diff = strokes - par;
    if (diff === 0) return 'par';
    if (diff === 1) return 'bogey';
    if (diff === -1) return 'birdie';
    return 'eagle'; // Simplified example
  }
  
  // ❌ DON'T: Use any type
  function unsafeCalculateScore(strokes: any, par: any): any {
    return strokes - par; // May produce NaN or other unexpected results
  }
  ```
