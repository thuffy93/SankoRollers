---
description: 
globs: 
alwaysApply: true
---
# TypeScript Class Implementation Best Practices

## Property Access Patterns
- Always provide public getter methods for private properties that might need external access
- Example: For boolean flags like `private isHighPerformanceMode`, include a corresponding `getIsHighPerformanceMode()` method
- This prevents compilation errors when properties are referenced from other files

## Three.js Vector Handling
- Always use `.clone()` or `.copy()` when passing Vector3 objects to prevent unintended mutations
- Example: `offset.clone()` instead of direct assignment to avoid shared references
- When setting a Vector3 from another, use `.copy()` rather than direct assignment

## Class Integration Pattern
- When providing a public API, define clear state transition methods (like `transitionToState`)
- Expose state enums (like `CameraState`) from the same file to ensure type consistency
- Design public methods to be "safe" with reasonable defaults and parameter validation

## Performance Optimization
- Include performance throttling for high-frequency operations
- Example: Implement frame skipping with `if (this.isHighPerformanceMode && (currentTime - this.lastUpdateTime) < this.updateInterval) { return; }`
- Provide methods to toggle performance modes based on device capabilities

## Event Management
- When registering event listeners in a component, ensure corresponding cleanup methods
- Example: Storing references to handlers and removing them in a `dispose()` method
- Use consistent patterns for enabling/disabling features (like our toggle methods)

## Debugging Helpers
- Include logging for state transitions and complex operations
- Add debug visualization options for physics objects, camera boundaries, etc.
- Consider performance monitoring for optimization (like our FPS tracking)