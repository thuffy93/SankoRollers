---
description: 
globs: 
alwaysApply: true
---
# Event Listener Management

- **Binding Event Handlers Correctly**
  - Store bound handler references to ensure proper cleanup
  - Use the same function reference for adding and removing listeners
  
  ```typescript
  // ✅ DO: Store bound handler references
  private readonly boundHandleMouseDown: (e: MouseEvent) => void;
  
  constructor() {
    // Bind once and store reference
    this.boundHandleMouseDown = this.handleMouseDown.bind(this);
    window.addEventListener('mousedown', this.boundHandleMouseDown);
  }
  
  dispose() {
    // Use same reference for removal
    window.addEventListener('mousedown', this.boundHandleMouseDown);
  }
  
  // ❌ DON'T: Bind handlers inline when adding/removing
  window.addEventListener('mousedown', this.handleMouseDown.bind(this)); // New function reference
  window.removeEventListener('mousedown', this.handleMouseDown.bind(this)); // Different reference!
  ```

- **Complete Event Cleanup**
  - Always remove ALL event listeners in dispose/cleanup methods
  - Document each registered event with its cleanup
  - Group related listeners together
  
  ```typescript
  // ✅ DO: Register and cleanup in matching pairs
  setupEventListeners(): void {
    // Mouse events
    window.addEventListener('mousedown', this.boundHandleMouseDown);
    window.addEventListener('mousemove', this.boundHandleMouseMove);
    window.addEventListener('mouseup', this.boundHandleMouseUp);
  }
  
  dispose(): void {
    // Remove all registered listeners
    window.removeEventListener('mousedown', this.boundHandleMouseDown);
    window.removeEventListener('mousemove', this.boundHandleMouseMove);
    window.removeEventListener('mouseup', this.boundHandleMouseUp);
  }
  
  // ❌ DON'T: Leave event listeners unremoved
  dispose(): void {
    // Missing removal of event listeners - memory leak!
  }
  ```

- **Event Handler Scope and Context**
  - Ensure 'this' is correctly bound in event handlers
  - Use arrow functions or explicit binding for class methods
  
  ```typescript
  // ✅ DO: Use class property arrow functions when appropriate
  private handleClick = (event: MouseEvent): void => {
    // 'this' refers to class instance automatically
    this.updateState(event);
  }
  
  // ✅ DO: Or bind methods in constructor
  constructor() {
    this.handleClick = this.handleClick.bind(this);
  }
  
  // ❌ DON'T: Use unbound methods directly
  window.addEventListener('click', this.handleClick); // 'this' will be window!
  ```

- **Passive and Capture Options**
  - Specify passive: true for scrolling/touch events to improve performance
  - Document when using capture phase listeners
  
  ```typescript
  // ✅ DO: Use passive for touch/wheel events
  element.addEventListener('touchmove', this.handleTouch, { passive: true });
  
  // ✅ DO: Document capture phase usage
  // Using capture phase to intercept events before child handlers
  parent.addEventListener('click', this.handleParentClick, { capture: true });
  
  // ❌ DON'T: Omit options when performance matters
  element.addEventListener('wheel', this.handleWheel); // Should be passive
  ```
